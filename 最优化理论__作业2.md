# 						  最优化理论__作业2

**学号：406100210008**  					**专业：计算机技术**

**姓名：潘奇**   									  **手机号：18636940978**

## 文档结构:

1.作业题目	2.最小二乘法问题相关以及题目设定	3.最小二乘法逼近超平面

4.作业总结

## 1.作业题目

实现最小二乘法的矩阵解法；随机生成m个n维点，用该最小二乘法代码计算其最佳逼近超平面，形成demo 

**要求**：至少体现核心代码解释，demo演示，结果分析等；禁用第三方API（定义数据结构的库除外），禁止抄袭

## 2.最小二乘法问题相关以及题目设定

**2.1题目设定：**生成188个3维点（x,y,z），一个一个设定点比较麻烦，而且不一定满足接近一个平面。用逆向思维来看，不如设定一个平面z=ax+by+c，再加上随机噪音，可以使这188个点分布在平面z=ax+by+c附近。这样获得的188个点即方便又符合题意。再利用最小二乘法求出系数a,b,c的值，再做出图即可。

**2.2最小二乘法：**用来函数拟合或者求函数极值的方法。

**超定方程组：**把方程个数大于未知数个数的方程组叫做超定方程组。



## 3.最小二乘法逼近超平面

#### 3.1解题过程：

首先获得188个初始点；

其次，因为z=ax+by+c可以表示成超定方程的形式AX=b;  其中A为188*3的矩阵，第一列为x（a的系数为x）,			第二列为y（b的系数为y）,第三列为1（c的系数为1），

​			其中X为待定系数[a,b,c]为3*1的矩阵，

​			其中b为z的值，即188*1的矩阵；

最后，将各个系数赋值给相应的矩阵，很方便地利用python求解即可得到系数[a,b,c]

即：

假设方程组AX=b，则求其最小二乘解只需要两边同时乘上A的转置，然后得到$\mathbf{A}^\mathrm{T}AX=\mathbf{A}^\mathrm{T}b$，

然后将$(\mathbf{A}^\mathrm{T}A)^{-1}$同时在等式左右的左方相乘，有X=$(\mathbf{A}^\mathrm{T}A)^{-1}$$\mathbf{A}^\mathrm{T}b$，即得到了未知的系数a,b,c

最后画图即可。

#### 3.2代码实现

没有引入任何第三方API，仅仅使用了numpy科学计算库以及画图工具需要的库matplotlib

```python
import numpy as np
import matplotlib.pyplot as plt
```

首先定义188个在平面附近的点，并且将各个数填入数组中方便计算，代码如下：

```python
def get_matrix(a, b, c):
    """
    逼近平面y=ax+by+c附近的188个随机点,转化为矩阵形式Ax=b
    :param a:x的系数
    :param b:y的系数
    :param c:常数项c
    :return: 矩阵系数A，b
    """
    # 创建函数，用于随机生成不同属于一个平面的188个离散点
    # np.random.uniform从均匀分布中随机采样
    x = np.random.uniform(-10, 10, size=188)
    y = np.random.uniform(-10, 10, size=188)
    z = (a * x + b * y + c) + np.random.normal(-0.5, 0.5, size=188)  # 加上了随机噪音

    # 创建系数矩阵A和b
    A = np.ones((188, 3))  # 188*3矩阵，全是1
    b = np.zeros((188, 1))  # 188*1矩阵，全是1
    for i in range(0, 188):  # A的前两列全部赋值为点x和y，第三列为1。b由z的值确定
        A[i, 0] = x[i]
        A[i, 1] = y[i]
        b[i, 0] = z[i]
    return A, b, x, y, z

```



之后定义了最小二乘法利用超定方程组直接解的方法：

```python
def matrix_compute(A, b):
    """X=(AT*A)-1*AT*b直接求解"""
    A_T = A.T  # 获得矩阵A的转置(3*188)
    AT_A = np.dot(A_T, A)  # 矩阵乘法(3*188)*(188*3)=(3*3)
    AT_A_reverse = np.linalg.inv(AT_A)  # 矩阵求逆(3*3)
    AT_A_reverse_A_T = np.dot(AT_A_reverse, A_T)  # (3*3)*(3*188)=(3*188)
    X = np.dot(AT_A_reverse_A_T, b)  # (3*188)*(188*1)=(3*1)
    print('最小二乘法拟合的最终平面为：z = %.2f * x + %.2f * y + %.2f' % (X[0, 0], X[1, 0], X[2, 0]))
    return X  # 获得系数a,b,c

```

#### 3.3结果分析

最后运行main()主函数，获得结果，其中平面设置为z=2x+8y+10，即这188个点都是在这个平面附近

```python
if __name__ == '__main__':
    # 获得题干的函数z=2x+8y+10，将其系数填入矩阵以及获得该188个点
    A, b, x, y, z = get_matrix(2, 8, 10)
    X = matrix_compute(A, b)  # 最小二乘法运算，获得未知系数a,b,c
    # 展示图像
    fig1 = plt.figure()
    ax1 = fig1.add_subplot(111, projection='3d')
    ax1.set_xlabel("x")  # 标签
    ax1.set_ylabel("y")
    ax1.set_zlabel("z")
    ax1.scatter(x, y, z, c='b', marker='o')  # 画出188个点的散点图
    x_p = np.linspace(-10, 10, 188)
    y_p = np.linspace(-10, 10, 188)
    x_p, y_p = np.meshgrid(x_p, y_p)
    z_p = X[0, 0] * x_p + X[1, 0] * y_p + X[2, 0]  # 画出最小二乘法拟合的平面
    ax1.plot_wireframe(x_p, y_p, z_p, rstride=15, cstride=15, color='r')
    plt.show()
```

运行一下，获得的结果部分如下所示：

-----------------------------------------------------------------------------------------------------------------------------------------------------------

最小二乘法拟合的最终平面为：z = 2.01 * x + 7.98 * y + 9.56

-----------------------------------------------------------------------------------------------------------------------------------------------------------

![myplot](C:\Users\枫\Desktop\myplot.png)



## 4.总结

以上代码均以保存到我本人的github中，作为学习过程中珍贵的记录，把链接奉上：

https://github.com/ncdxpq/optimization_theory_homework2.git

感谢肖艳阳老师的课程，在最优化理论这门课中，我学习到了非常多的数学知识，是肖老师让我进一步理解了数学的美妙之处。通过完成本次作业，我对最小二乘法有了更深的理解，对函数逼近的概念的神奇之处感到惊叹，谢谢！

